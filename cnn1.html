<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CNN Visualizer: Redes Neurais Convolucionais</title>
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #f5f7fb;
      padding: 20px;
      margin: 0;
      color: #333;
    }
    .container {
      max-width: 1100px;
      margin: auto;
      padding: 20px;
    }
    .card {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .button {
      padding: 10px 15px;
      margin: 10px 5px;
      font-size: 16px;
      background-color: #4caf50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .back-button {
      display: inline-flex;
      align-items: center;
      color: blue;
      font-weight: bold;
      margin-bottom: 20px;
      text-decoration: none;
    }
    .button:hover {
      background-color: #45a049;
    }
    .button-blue {
      background-color: #2196f3;
    }
    .button-blue:hover {
      background-color: #0b7dda;
    }
    .button-orange {
      background-color: #ff9800;
    }
    .button-orange:hover {
      background-color: #e68a00;
    }
    canvas {
      border: 1px solid #ccc;
      background-color: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
    }
    .control-group {
      flex: 1;
      min-width: 200px;
    }
    .slider-container {
      margin-bottom: 15px;
    }
    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    .slider {
      width: 100%;
    }
    /* Modificação principal: mudar de grid para layout vertical */
    .vertical-layout {
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }
    /* Manter grid apenas para mobile responsiveness */
    @media (max-width: 768px) {
      .vertical-layout {
        gap: 15px;
      }
    }
    .explanation {
      background-color: #e7f3fe;
      border-left: 6px solid #2196F3;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 4px;
    }
    h2 {
      color: #333;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    .cnn-visualizer {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .canvas-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
    }
    .canvas-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .canvas-title {
      font-weight: bold;
      margin-bottom: 5px;
      margin-top: 10px;
      text-align: center;
    }
    .feature-map-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-top: 20px;
    }
    .feature-map {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .feature-map-title {
      font-size: 12px;
      text-align: center;
      margin-top: 5px;
    }
    .tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 20px;
    }
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      background-color: #f8f9fa;
      border: 1px solid #ddd;
      border-bottom: none;
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
      margin-right: 5px;
    }
    .tab.active {
      background-color: white;
      border-bottom: 2px solid white;
      margin-bottom: -1px;
      font-weight: bold;
    }
    .drawing-tools {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }
    .tool-button {
      padding: 5px 10px;
      background-color: #f1f1f1;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
    }
    .tool-button.active {
      background-color: #e0e0e0;
      font-weight: bold;
    }
    .preset-images {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    .preset-image {
      width: 50px;
      height: 50px;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      object-fit: cover;
    }
    .preset-image:hover {
      border-color: #2196f3;
    }
    .color-picker {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .brush-size-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .flow-arrow {
      font-size: 24px;
      color: #555;
      margin: 10px 0;
    }
    .flow-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 20px;
    }
  </style>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
  <div class="container">
    <a href="index.html" class="back-button">
      ← Voltar para Ferramentas
    </a>
    <h1>CNN Visualizer: Redes Neurais Convolucionais</h1>
    <div class="explanation">
      <h3>Como funcionam as CNNs?</h3>
      <p>As Redes Neurais Convolucionais (CNNs) são projetadas especificamente para processar dados em formato de grade, como imagens. Elas aplicam operações de convolução para extrair características locais e reduzir a dimensionalidade dos dados.</p>
      <ol>
        <li><strong>Camada Convolucional:</strong> Aplica filtros (kernels) à imagem para detectar características específicas como bordas, texturas, etc.</li>
        <li><strong>Função de Ativação:</strong> Introduz não-linearidade, geralmente usando ReLU (Rectified Linear Unit).</li>
        <li><strong>Camada de Pooling:</strong> Reduz a dimensionalidade espacial, preservando as características mais importantes.</li>
        <li><strong>Camadas Totalmente Conectadas:</strong> Realizam a classificação final com base nas características extraídas.</li>
      </ol>
      <p>Esta visualização permite ver como cada camada transforma a imagem e extrai características de mais alto nível.</p>
    </div>

    <div id="app"></div>
  </div>

  <script type="text/babel">
    // Funções de utilidade para CNNs
    
    // Aplicar ReLU - Função de ativação que substitui valores negativos por zero
    const relu = (x) => Math.max(0, x);
    
    // Aplicar convolução a uma matriz 2D com um kernel
    const convolve = (matrix, kernel, stride = 1, padding = 0) => {
      // Adicionar padding à matriz original se necessário
      let paddedMatrix = matrix;
      if (padding > 0) {
        paddedMatrix = [];
        const paddedSize = matrix.length + 2 * padding;
        for (let i = 0; i < paddedSize; i++) {
          paddedMatrix[i] = Array(paddedSize).fill(0);
        }
        for (let i = 0; i < matrix.length; i++) {
          for (let j = 0; j < matrix[i].length; j++) {
            paddedMatrix[i + padding][j + padding] = matrix[i][j];
          }
        }
      }
      
      // Calcular dimensões da matriz resultante
      const resultSize = Math.floor((paddedMatrix.length - kernel.length) / stride) + 1;
      const result = Array(resultSize).fill().map(() => Array(resultSize).fill(0));
      
      // Aplicar convolução
      for (let i = 0; i < resultSize; i++) {
        for (let j = 0; j < resultSize; j++) {
          let sum = 0;
          for (let ki = 0; ki < kernel.length; ki++) {
            for (let kj = 0; kj < kernel[ki].length; kj++) {
              sum += paddedMatrix[i * stride + ki][j * stride + kj] * kernel[ki][kj];
            }
          }
          result[i][j] = sum;
        }
      }
      
      return result;
    };
    
    // Aplicar max pooling a uma matriz 2D
    const maxPooling = (matrix, poolSize = 2, stride = 2) => {
      const resultSize = Math.floor((matrix.length - poolSize) / stride) + 1;
      const result = Array(resultSize).fill().map(() => Array(resultSize).fill(0));
      
      for (let i = 0; i < resultSize; i++) {
        for (let j = 0; j < resultSize; j++) {
          let maxVal = -Infinity;
          for (let pi = 0; pi < poolSize; pi++) {
            for (let pj = 0; pj < poolSize; pj++) {
              const val = matrix[i * stride + pi][j * stride + pj];
              maxVal = Math.max(maxVal, val);
            }
          }
          result[i][j] = maxVal;
        }
      }
      
      return result;
    };
    
    // Kernels (filtros) para detecção de características específicas
    const getPresetKernels = () => {
      return {
        // Detector de bordas horizontais
        horizontalEdge: [
          [-1, -1, -1],
          [0, 0, 0],
          [1, 1, 1]
        ],
        
        // Detector de bordas verticais
        verticalEdge: [
          [-1, 0, 1],
          [-1, 0, 1],
          [-1, 0, 1]
        ],
        
        // Detector de bordas (Sobel horizontal)
        sobelHorizontal: [
          [-1, -2, -1],
          [0, 0, 0],
          [1, 2, 1]
        ],
        
        // Detector de bordas (Sobel vertical)
        sobelVertical: [
          [-1, 0, 1],
          [-2, 0, 2],
          [-1, 0, 1]
        ],
        
        // Filtro de nitidez (Sharpen)
        sharpen: [
          [0, -1, 0],
          [-1, 5, -1],
          [0, -1, 0]
        ],
        
        // Filtro Gaussiano (para desfoque/suavização)
        gaussian: [
          [1/16, 2/16, 1/16],
          [2/16, 4/16, 2/16],
          [1/16, 2/16, 1/16]
        ],
        
        // Detector de todos os bordas (Laplaciano)
        laplacian: [
          [0, 1, 0],
          [1, -4, 1],
          [0, 1, 0]
        ],
        
        // Filtro de identidade (não altera a imagem)
        identity: [
          [0, 0, 0],
          [0, 1, 0],
          [0, 0, 0]
        ]
      };
    };
    
    // Componente principal da aplicação
    const App = () => {
      // Referências para os canvas
      const inputCanvasRef = React.useRef(null);
      const convLayerCanvasRef = React.useRef(null);
      const poolingLayerCanvasRef = React.useRef(null);
      const featureMapRefs = React.useRef({});
      
      // Estado do componente
      const [inputSize, setInputSize] = React.useState(28); // Tamanho da imagem de entrada (28x28 pixels)
      const [kernelSize, setKernelSize] = React.useState(3); // Tamanho do kernel (filtro)
      const [stride, setStride] = React.useState(1); // Passo da convolução
      const [padding, setPadding] = React.useState(1); // Padding
      const [poolingSize, setPoolingSize] = React.useState(2); // Tamanho do pooling
      const [poolingStride, setPoolingStride] = React.useState(2); // Passo do pooling
      const [activeKernel, setActiveKernel] = React.useState("sobelHorizontal"); // Kernel ativo
      const [customKernel, setCustomKernel] = React.useState(
        Array(kernelSize).fill().map(() => Array(kernelSize).fill(0))
      ); // Kernel personalizado
      const [useCustomKernel, setUseCustomKernel] = React.useState(false); // Usar kernel personalizado
      const [activeTab, setActiveTab] = React.useState("draw"); // Aba ativa
      const [drawing, setDrawing] = React.useState(false); // Estado do desenho
      const [drawingTool, setDrawingTool] = React.useState("pencil"); // Ferramenta de desenho
      const [brushSize, setBrushSize] = React.useState(2); // Tamanho do pincel
      const [brushColor, setBrushColor] = React.useState("#000000"); // Cor do pincel
      const [presetKernels] = React.useState(getPresetKernels()); // Kernels pré-definidos
      const [numFeatureMaps, setNumFeatureMaps] = React.useState(8); // Número de mapas de características
      const [imageInput, setImageInput] = React.useState([]);
      const [convOutput, setConvOutput] = React.useState([]);
      const [poolingOutput, setPoolingOutput] = React.useState([]);
      const [featureMaps, setFeatureMaps] = React.useState([]);
      
      // Inicializar imagem de entrada
      React.useEffect(() => {
        // Criar matriz de entrada vazia
        const emptyInput = Array(inputSize).fill().map(() => Array(inputSize).fill(0));
        setImageInput(emptyInput);
        
        // Inicializar canvas
        setTimeout(() => {
          clearInputCanvas();
          applyProcessing();
        }, 100);
      }, [inputSize]);
      
      // Atualizar kernel personalizado quando o tamanho mudar
      React.useEffect(() => {
        setCustomKernel(Array(kernelSize).fill().map(() => Array(kernelSize).fill(0)));
      }, [kernelSize]);
      
      // Gerar kernels aleatórios para mapas de características
      const generateRandomKernels = () => {
        const kernels = [];
        for (let i = 0; i < numFeatureMaps; i++) {
          const kernel = Array(kernelSize).fill().map(() => 
            Array(kernelSize).fill().map(() => Math.random() * 2 - 1)
          );
          kernels.push(kernel);
        }
        return kernels;
      };
      
      // Desenhar em um canvas
      const drawToCanvas = (canvas, matrix, colorScale = true) => {
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const cellSize = Math.min(width / matrix[0].length, height / matrix.length);
        
        ctx.clearRect(0, 0, width, height);
        
        // Encontrar valores mínimos e máximos para normalização
        let min = Infinity;
        let max = -Infinity;
        
        for (let i = 0; i < matrix.length; i++) {
          for (let j = 0; j < matrix[i].length; j++) {
            min = Math.min(min, matrix[i][j]);
            max = Math.max(max, matrix[i][j]);
          }
        }
        
        // Desenhar matriz
        for (let i = 0; i < matrix.length; i++) {
          for (let j = 0; j < matrix[i].length; j++) {
            let value = matrix[i][j];
            
            if (colorScale) {
              // Normalizar valor
              let normalizedValue;
              if (max === min) {
                normalizedValue = value > 0 ? 1 : 0;
              } else {
                normalizedValue = (value - min) / (max - min);
              }
              
              // Escala de cinza
              const colorValue = Math.floor(normalizedValue * 255);
              ctx.fillStyle = `rgb(${colorValue}, ${colorValue}, ${colorValue})`;
            } else {
              // Valores binários (preto e branco)
              ctx.fillStyle = value > 0 ? 'black' : 'white';
            }
            
            ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
          }
        }
      };
      
      // Limpar canvas de entrada
      const clearInputCanvas = () => {
        const canvas = inputCanvasRef.current;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Reiniciar matriz de entrada
        const emptyInput = Array(inputSize).fill().map(() => Array(inputSize).fill(0));
        setImageInput(emptyInput);
      };
      
      // Capturar imagem do canvas de entrada
      const captureInputImage = () => {
        const canvas = inputCanvasRef.current;
        if (!canvas) return Array(inputSize).fill().map(() => Array(inputSize).fill(0));
        
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Converter para matriz de entrada
        const cellSize = canvas.width / inputSize;
        const input = Array(inputSize).fill().map(() => Array(inputSize).fill(0));
        
        for (let i = 0; i < inputSize; i++) {
          for (let j = 0; j < inputSize; j++) {
            // Calcular posição no centro da célula
            const x = Math.floor(j * cellSize + cellSize / 2);
            const y = Math.floor(i * cellSize + cellSize / 2);
            
            // Obter cor do pixel (apenas canal vermelho para simplicidade)
            const pixelIndex = (y * canvas.width + x) * 4;
            const r = data[pixelIndex];
            const g = data[pixelIndex + 1];
            const b = data[pixelIndex + 2];
            
            // Converter para valor entre 0 e 1 (invertido, pois preto = 1, branco = 0)
            const grayValue = 1 - (r + g + b) / (3 * 255);
            input[i][j] = grayValue;
          }
        }
        
        return input;
      };
      
      // Criar kernel a partir do kernel ativo
      const getActiveKernel = () => {
        if (useCustomKernel) {
          return customKernel;
        } else {
          return presetKernels[activeKernel];
        }
      };
      
      // Aplicar processamento da CNN
      const applyProcessing = () => {
        // Capturar imagem do canvas de entrada
        const input = captureInputImage();
        setImageInput(input);
        
        // Aplicar convolução
        const kernel = getActiveKernel();
        const convResult = convolve(input, kernel, stride, padding);
        
        // Aplicar ReLU
        const reluResult = convResult.map(row => row.map(relu));
        setConvOutput(reluResult);
        
        // Aplicar Max Pooling
        const poolResult = maxPooling(reluResult, poolingSize, poolingStride);
        setPoolingOutput(poolResult);
        
        // Gerar mapas de características
        const randomKernels = generateRandomKernels();
        const maps = randomKernels.map(kernel => {
          const convResult = convolve(input, kernel, stride, padding);
          const reluResult = convResult.map(row => row.map(relu));
          return reluResult;
        });
        setFeatureMaps(maps);
        
        // Redesenhar camadas
        drawToCanvas(convLayerCanvasRef.current, reluResult);
        drawToCanvas(poolingLayerCanvasRef.current, poolResult);
        
        // Desenhar mapas de características
        setTimeout(() => {
          maps.forEach((map, index) => {
            const canvasRef = featureMapRefs.current[`featureMap-${index}`];
            if (canvasRef) {
              drawToCanvas(canvasRef, map);
            }
          });
        }, 0);
      };
      
      // Manipuladores de eventos para desenho no canvas
      const handleMouseDown = (e) => {
        setDrawing(true);
        const canvas = inputCanvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (drawingTool === "pencil") {
          draw(x, y);
        } else if (drawingTool === "eraser") {
          erase(x, y);
        }
      };
      
      const handleMouseMove = (e) => {
        if (!drawing) return;
        const canvas = inputCanvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (drawingTool === "pencil") {
          draw(x, y);
        } else if (drawingTool === "eraser") {
          erase(x, y);
        }
      };
      
      const handleMouseUp = () => {
        setDrawing(false);
        applyProcessing();
      };
      
      const handleMouseLeave = () => {
        setDrawing(false);
      };
      
      // Desenhar no canvas
      const draw = (x, y) => {
        const canvas = inputCanvasRef.current;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = brushColor;
        ctx.beginPath();
        ctx.arc(x, y, brushSize, 0, Math.PI * 2);
        ctx.fill();
      };
      
      // Apagar do canvas
      const erase = (x, y) => {
        const canvas = inputCanvasRef.current;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(x, y, brushSize, 0, Math.PI * 2);
        ctx.fill();
      };
      
      // Carregar imagem pré-definida
      const loadPresetImage = (preset) => {
        clearInputCanvas();
        
        const canvas = inputCanvasRef.current;
        const ctx = canvas.getContext('2d');
        
        // Desenhar forma básica
        ctx.fillStyle = 'black';
        ctx.strokeStyle = 'black';
        
        switch (preset) {
          case 'horizontal':
            // Desenhar uma linha horizontal mais grossa para melhor detecção
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.2, canvas.height * 0.5);
            ctx.lineTo(canvas.width * 0.8, canvas.height * 0.5);
            ctx.stroke();
            break;
          case 'vertical':
            // Desenhar uma linha vertical mais grossa para melhor detecção
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.5, canvas.height * 0.2);
            ctx.lineTo(canvas.width * 0.5, canvas.height * 0.8);
            ctx.stroke();
            break;
          case 'square':
            // Desenhar um quadrado preenchido para melhor detecção
            ctx.fillRect(canvas.width * 0.25, canvas.height * 0.25, canvas.width * 0.5, canvas.height * 0.5);
            break;
          case 'circle':
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(canvas.width * 0.5, canvas.height * 0.5, canvas.width * 0.3, 0, Math.PI * 2);
            ctx.stroke();
            break;
          case 'cross':
            // Desenhar uma cruz mais grossa
            ctx.lineWidth = 6;
            
            // Linha horizontal
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.2, canvas.height * 0.5);
            ctx.lineTo(canvas.width * 0.8, canvas.height * 0.5);
            ctx.stroke();
            
            // Linha vertical
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.5, canvas.height * 0.2);
            ctx.lineTo(canvas.width * 0.5, canvas.height * 0.8);
            ctx.stroke();
            break;
          case 'diagonal':
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.2, canvas.height * 0.2);
            ctx.lineTo(canvas.width * 0.8, canvas.height * 0.8);
            ctx.stroke();
            break;
          case 'triangle':
            // Desenhar um triângulo preenchido para melhor detecção
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.5, canvas.height * 0.2);
            ctx.lineTo(canvas.width * 0.8, canvas.height * 0.8);
            ctx.lineTo(canvas.width * 0.2, canvas.height * 0.8);
            ctx.closePath();
            ctx.fill();
            break;
          case 'grid':
            ctx.lineWidth = 5;
            
            // Linhas horizontais
            for (let i = 1; i < 3; i++) {
              ctx.beginPath();
              ctx.moveTo(canvas.width * 0.2, canvas.height * (i * 0.25 + 0.25));
              ctx.lineTo(canvas.width * 0.8, canvas.height * (i * 0.25 + 0.25));
              ctx.stroke();
            }
            
            // Linhas verticais
            for (let i = 1; i < 3; i++) {
              ctx.beginPath();
              ctx.moveTo(canvas.width * (i * 0.25 + 0.25), canvas.height * 0.2);
              ctx.lineTo(canvas.width * (i * 0.25 + 0.25), canvas.height * 0.8);
              ctx.stroke();
            }
            break;
          default:
            break;
        }
        
        // Atualizar processamento imediatamente
        applyProcessing();
      };
      
      // Atualizar valor do kernel personalizado
      const updateCustomKernelValue = (row, col, value) => {
        const newKernel = [...customKernel];
        newKernel[row][col] = parseFloat(value) || 0;
        setCustomKernel(newKernel);
      };
      
      // Renderizar tabela do kernel personalizado
      const renderCustomKernelTable = () => {
        return (
          <div style={{ marginBottom: '20px' }}>
            <h3>Kernel Personalizado</h3>
            <table style={{ borderCollapse: 'collapse', margin: 'auto' }}>
              <tbody>
                {customKernel.map((row, rowIndex) => (
                  <tr key={`kernel-row-${rowIndex}`}>
                    {row.map((value, colIndex) => (
                      <td key={`kernel-cell-${rowIndex}-${colIndex}`} style={{ border: '1px solid #ddd', padding: '5px' }}>
                        <input
                          type="number"
                          step="0.1"
                          value={value}
                          onChange={(e) => updateCustomKernelValue(rowIndex, colIndex, e.target.value)}
                          style={{ width: '50px', textAlign: 'center' }}
                        />
                      </td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        );
      };
      
      // Renderizar lista de kernels pré-definidos
      const renderPresetKernels = () => {
        return (
          <div style={{ marginBottom: '20px' }}>
            <h3>Filtros Pré-definidos</h3>
            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '10px' }}>
              {Object.keys(presetKernels).map((kernelName) => (
                <button
                  key={kernelName}
                  className={`button ${activeKernel === kernelName && !useCustomKernel ? 'button-blue' : ''}`}
                  onClick={() => {
                    setActiveKernel(kernelName);
                    setUseCustomKernel(false);
                    setTimeout(() => applyProcessing(), 100);
                  }}
                >
                  {formatKernelName(kernelName)}
                </button>
              ))}
              <button
                className={`button ${useCustomKernel ? 'button-blue' : ''}`}
                onClick={() => {
                  setUseCustomKernel(true);
                  setTimeout(() => applyProcessing(), 100);
                }}
              >
                Kernel Personalizado
              </button>
            </div>
          </div>
        );
      };
      
      // Formatar nome do kernel para exibição
      const formatKernelName = (name) => {
        return name
          .replace(/([A-Z])/g, ' $1') // Adicionar espaço antes de letra maiúscula
          .replace(/^./, (str) => str.toUpperCase()); // Primeira letra maiúscula
      };
      
      return (
        <div>
          <div className="tabs">
            <div 
              className={`tab ${activeTab === 'draw' ? 'active' : ''}`}
              onClick={() => setActiveTab('draw')}
            >
              Desenhar Entrada
            </div>
            <div 
              className={`tab ${activeTab === 'filter' ? 'active' : ''}`}
              onClick={() => setActiveTab('filter')}
            >
              Configurar Filtros
            </div>
            <div 
              className={`tab ${activeTab === 'featureMaps' ? 'active' : ''}`}
              onClick={() => setActiveTab('featureMaps')}
            >
              Mapas de Características
            </div>
          </div>
          
          {activeTab === 'draw' && (
            <div className="card">
              <h2>Desenhar Imagem de Entrada</h2>
              
              <div className="drawing-tools">
                <div
                  className={`tool-button ${drawingTool === 'pencil' ? 'active' : ''}`}
                  onClick={() => setDrawingTool('pencil')}
                >
                  Lápis
                </div>
                <div
                  className={`tool-button ${drawingTool === 'eraser' ? 'active' : ''}`}
                  onClick={() => setDrawingTool('eraser')}
                >
                  Borracha
                </div>
                <div className="brush-size-controls">
                  <span>Tamanho: </span>
                  <input
                    type="range"
                    min="1"
                    max="10"
                    value={brushSize}
                    onChange={(e) => setBrushSize(parseInt(e.target.value))}
                  />
                  <span>{brushSize}px</span>
                </div>
                {drawingTool === 'pencil' && (
                  <div className="color-picker">
                    <span>Cor: </span>
                    <input
                      type="color"
                      value={brushColor}
                      onChange={(e) => setBrushColor(e.target.value)}
                    />
                  </div>
                )}
                <button className="button button-orange" onClick={clearInputCanvas}>
                  Limpar
                </button>
              </div>
              
              <h3>Formas Pré-definidas</h3>
              <div className="preset-images">
                <button className="button" onClick={() => loadPresetImage('square')}>Quadrado</button>
                <button className="button" onClick={() => loadPresetImage('circle')}>Círculo</button>
                <button className="button" onClick={() => loadPresetImage('diagonal')}>Diagonal</button>
                <button className="button" onClick={() => loadPresetImage('triangle')}>Triângulo</button>
              </div>
              
              <div className="canvas-container">
                <div className="canvas-wrapper">
                  <div className="canvas-title">Imagem de Entrada</div>
                  <canvas
                    ref={inputCanvasRef}
                    width="200"
                    height="200"
                    style={{ border: '1px solid #ccc', margin: '10px' }}
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseLeave}
                  />
                </div>
              </div>
              
              {/* Layout vertical para as saídas das camadas */}
              <div className="vertical-layout" style={{ marginTop: '20px' }}>
                <div className="flow-arrow">↓</div>
                
                <div className="canvas-wrapper">
                  <div className="canvas-title">Saída da Camada Convolucional + ReLU</div>
                  <canvas
                    ref={convLayerCanvasRef}
                    width="200"
                    height="200"
                    style={{ border: '1px solid #ccc' }}
                  />
                </div>
                
                <div className="flow-arrow">↓</div>
                
                <div className="canvas-wrapper">
                  <div className="canvas-title">Saída da Camada de Pooling</div>
                  <canvas
                    ref={poolingLayerCanvasRef}
                    width="200"
                    height="200"
                    style={{ border: '1px solid #ccc' }}
                  />
                </div>
              </div>
            </div>
          )}
          
          {activeTab === 'filter' && (
            <div className="card">
              <h2>Configuração dos Filtros</h2>
              
              <div className="controls">
                <div className="control-group">
                  <div className="slider-container">
                    <div className="slider-label">
                      <span>Tamanho do Kernel:</span>
                      <span>{kernelSize}x{kernelSize}</span>
                    </div>
                    <input
                      type="range"
                      min="3"
                      max="7"
                      step="2"
                      value={kernelSize}
                      onChange={(e) => {
                        setKernelSize(parseInt(e.target.value));
                        setTimeout(() => applyProcessing(), 100);
                      }}
                      className="slider"
                    />
                  </div>
                  
                  <div className="slider-container">
                    <div className="slider-label">
                      <span>Stride (Passo):</span>
                      <span>{stride}</span>
                    </div>
                    <input
                      type="range"
                      min="1"
                      max="3"
                      value={stride}
                      onChange={(e) => {
                        setStride(parseInt(e.target.value));
                        setTimeout(() => applyProcessing(), 100);
                      }}
                      className="slider"
                    />
                  </div>
                  
                  <div className="slider-container">
                    <div className="slider-label">
                      <span>Padding:</span>
                      <span>{padding}</span>
                    </div>
                    <input
                      type="range"
                      min="0"
                      max="3"
                      value={padding}
                      onChange={(e) => {
                        setPadding(parseInt(e.target.value));
                        setTimeout(() => applyProcessing(), 100);
                      }}
                      className="slider"
                    />
                  </div>
                </div>
                
                <div className="control-group">
                  <div className="slider-container">
                    <div className="slider-label">
                      <span>Tamanho do Pooling:</span>
                      <span>{poolingSize}x{poolingSize}</span>
                    </div>
                    <input
                      type="range"
                      min="2"
                      max="4"
                      value={poolingSize}
                      onChange={(e) => {
                        setPoolingSize(parseInt(e.target.value));
                        setTimeout(() => applyProcessing(), 100);
                      }}
                      className="slider"
                    />
                  </div>
                  
                  <div className="slider-container">
                    <div className="slider-label">
                      <span>Stride do Pooling:</span>
                      <span>{poolingStride}</span>
                    </div>
                    <input
                      type="range"
                      min="1"
                      max="3"
                      value={poolingStride}
                      onChange={(e) => {
                        setPoolingStride(parseInt(e.target.value));
                        setTimeout(() => applyProcessing(), 100);
                      }}
                      className="slider"
                    />
                  </div>
                </div>
              </div>
              
              {renderPresetKernels()}
              
              {useCustomKernel && renderCustomKernelTable()}
              
              <div className="explanation">
                <h3>Visualização dos Filtros</h3>
                <p>Os filtros (kernels) são aplicados em toda a imagem através de uma operação de convolução. Cada filtro destaca características específicas:</p>
                <ul>
                  <li><strong>Detectores de bordas:</strong> Realçam transições bruscas na intensidade da imagem (bordas).</li>
                  <li><strong>Filtros de suavização:</strong> Reduzem ruído e detalhes finos.</li>
                  <li><strong>Filtros de nitidez:</strong> Enfatizam detalhes e bordas.</li>
                </ul>
                <p>Experimente diferentes filtros para ver como eles afetam a imagem de entrada!</p>
              </div>
            </div>
          )}
          
          {activeTab === 'featureMaps' && (
            <div className="card">
              <h2>Mapas de Características</h2>
              
              <div className="slider-container">
                <div className="slider-label">
                  <span>Número de Mapas:</span>
                  <span>{numFeatureMaps}</span>
                </div>
                <input
                  type="range"
                  min="4"
                  max="16"
                  step="4"
                  value={numFeatureMaps}
                  onChange={(e) => {
                    setNumFeatureMaps(parseInt(e.target.value));
                    setTimeout(() => applyProcessing(), 100);
                  }}
                  className="slider"
                />
              </div>
              
              <p>Em uma CNN real, múltiplos filtros são aplicados à mesma entrada para criar vários mapas de características. Cada filtro detecta diferentes padrões na imagem.</p>
              
              <div className="feature-map-grid">
                {Array.from({ length: numFeatureMaps }).map((_, index) => (
                  <div key={`feature-${index}`} className="feature-map">
                    <canvas
                      ref={el => featureMapRefs.current[`featureMap-${index}`] = el}
                      width="100"
                      height="100"
                      style={{ border: '1px solid #ccc' }}
                    />
                    <div className="feature-map-title">Filtro {index + 1}</div>
                  </div>
                ))}
              </div>
              
              <div className="explanation" style={{ marginTop: '20px' }}>
                <h3>Entendendo Mapas de Características</h3>
                <p>Os mapas de características são o resultado da aplicação de diferentes filtros à imagem de entrada:</p>
                <ul>
                  <li>Cada mapa destaca padrões específicos como bordas verticais, horizontais, texturas, etc.</li>
                  <li>Camadas mais profundas podem detectar padrões cada vez mais complexos e abstratos.</li>
                  <li>Quanto mais filtros, mais características a rede pode aprender a reconhecer.</li>
                </ul>
                <p>As CNNs combinam esses mapas de características nas camadas totalmente conectadas para realizar a classificação final.</p>
              </div>
            </div>
          )}
          
          <div className="card">
            <h2>Como as CNNs processam imagens</h2>
            <div className="explanation">
              <h3>Fluxo de Processamento:</h3>
              <ol>
                <li>
                  <strong>Camada Convolucional:</strong> Aplica filtros (kernels) à imagem para detectar características.
                  <ul>
                    <li><strong>Kernel:</strong> Matriz pequena que desliza sobre a imagem.</li>
                    <li><strong>Stride:</strong> Determina quanto o kernel "desliza" a cada passo.</li>
                    <li><strong>Padding:</strong> Adiciona zeros ao redor da imagem para preservar dimensões.</li>
                  </ul>
                </li>
                <li>
                  <strong>Ativação ReLU:</strong> Adiciona não-linearidade, substituindo valores negativos por zero.
                </li>
                <li>
                  <strong>Pooling:</strong> Reduz dimensões espaciais mantendo informações importantes.
                  <ul>
                    <li><strong>Max Pooling:</strong> Seleciona o valor máximo em cada região.</li>
                    <li>Ajuda a tornar a detecção de características invariante a pequenas translações.</li>
                  </ul>
                </li>
                <li>
                  <strong>Camadas Totalmente Conectadas:</strong> Combinam todas as características para classificação.
                </li>
              </ol>
              
              <h3>Benefícios das CNNs:</h3>
              <ul>
                <li>Reduzem significativamente o número de parâmetros comparado às redes totalmente conectadas.</li>
                <li>Preservam relações espaciais entre pixels.</li>
                <li>Compartilhamento de pesos permite detectar características independentemente de sua posição na imagem.</li>
                <li>Altamente eficazes para processamento de imagens, reconhecimento de objetos, segmentação, etc.</li>
              </ul>
            </div>
          </div>
        </div>
      );
    };

    // Renderizar o componente React
    ReactDOM.render(<App />, document.getElementById("app"));
  </script>
</body>
</html>
