<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multilayer Perceptron - IFSC IA</title>
    
    <!-- React e ReactDOM -->
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    
    <!-- Babel para JSX -->
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    
    <style>
        body {
            font-family: -apple-system, sans-serif;
            background-color: #f5f7fb;
            padding: 20px;
            margin: 0;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .back-button {
            display: inline-flex;
            align-items: center;
            color: blue;
            font-weight: bold;
            margin-bottom: 20px;
            text-decoration: none;
        }
        
        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .button {
            padding: 8px 16px;
            background: #4c6ef5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        
        .button:hover {
            background: #364fc7;
        }
        
        .button:disabled {
            background: #adb5bd;
            cursor: not-allowed;
        }
        
        .button-green {
            background: #40c057;
        }
        
        .button-green:hover {
            background: #2b9348;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .mb-4 {
            margin-bottom: 16px;
        }
        
        .progress-bar {
            width: 100%;
            background-color: #e9ecef;
            border-radius: 4px;
            height: 8px;
            overflow: hidden;
        }
        
        .progress-bar-fill {
            height: 100%;
            background-color: #4c6ef5;
            transition: width 0.2s;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-button">
            ← Voltar para Ferramentas
        </a>
        
        <h1>Multilayer Perceptron</h1>
        <p>Visualize como um perceptron multicamadas cria regiões de decisão complexas</p>
        
        <div id="app-container" class="card"></div>
        
        <div class="card">
            <h2>Teoria do Multilayer Perceptron (MLP)</h2>
            <p>O Multilayer Perceptron (MLP) é uma rede neural com múltiplas camadas que podem aprender padrões não-lineares complexos.</p>
            <p>Diferente de um único perceptron que só pode criar um hiperplano linear, um MLP combina vários hiperplanos para formar fronteiras de decisão complexas.</p>
            <p>Cada neurônio nas camadas ocultas contribui com seu próprio hiperplano, permitindo que a rede aprenda padrões que não são linearmente separáveis, como o problema XOR.</p>
            <p>Explore diferentes arquiteturas e observe como as fronteiras de decisão mudam com o número de camadas e neurônios.</p>
        </div>
        
        <footer style="text-align: center; margin-top: 40px; color: #6c757d;">
            <p>Desenvolvido por Ramon Mayor Martins - IFSC 2025</p>
            <p>Instituto Federal de Santa Catarina - Área de Telecomunicações</p>
        </footer>
    </div>
    
    <script type="text/babel">
        // Componente principal
        const MLPDemo = () => {
            // Estados
            const [numLayers, setNumLayers] = React.useState(1);
            const [neurons, setNeurons] = React.useState([4]);
            const [epoch, setEpoch] = React.useState(0);
            const [maxEpochs, setMaxEpochs] = React.useState(50);
            const [training, setTraining] = React.useState(false);
            const [points, setPoints] = React.useState([]);
            
            // Refs para canvas
            const dataCanvasRef = React.useRef(null);
            const networkCanvasRef = React.useRef(null);
            
            // Ref para modelo TensorFlow
            const model = React.useRef(null);
            
            // Gerar pontos XOR ao iniciar
            React.useEffect(() => {
                generateXORPoints();
            }, []);
            
            // Atualizar visualizações quando necessário
            React.useEffect(() => {
                if (dataCanvasRef.current) {
                    drawPoints();
                }
                if (networkCanvasRef.current) {
                    drawNetwork();
                }
            }, [points, neurons, numLayers, epoch]);
            
            // Atualizar neurônios quando o número de camadas muda
            React.useEffect(() => {
                const newNeurons = Array(numLayers).fill(4);
                setNeurons(newNeurons);
            }, [numLayers]);
            
            // Gerar pontos XOR
            const generateXORPoints = () => {
                const newPoints = [];
                const count = 100;
                const jitter = 0.1;
                
                for (let i = 0; i < count / 4; i++) {
                    // Pontos no quadrante 1 (superior direito) - Classe 0
                    newPoints.push({ 
                        x: 0.5 + (Math.random() * jitter * 2 - jitter), 
                        y: 0.5 + (Math.random() * jitter * 2 - jitter), 
                        class: 0 
                    });
                    
                    // Pontos no quadrante 3 (inferior esquerdo) - Classe 0
                    newPoints.push({ 
                        x: -0.5 + (Math.random() * jitter * 2 - jitter), 
                        y: -0.5 + (Math.random() * jitter * 2 - jitter), 
                        class: 0 
                    });
                    
                    // Pontos no quadrante 2 (superior esquerdo) - Classe 1
                    newPoints.push({ 
                        x: -0.5 + (Math.random() * jitter * 2 - jitter), 
                        y: 0.5 + (Math.random() * jitter * 2 - jitter), 
                        class: 1 
                    });
                    
                    // Pontos no quadrante 4 (inferior direito) - Classe 1
                    newPoints.push({ 
                        x: 0.5 + (Math.random() * jitter * 2 - jitter), 
                        y: -0.5 + (Math.random() * jitter * 2 - jitter), 
                        class: 1 
                    });
                }
                
                setPoints(newPoints);
                setEpoch(0);
            };
            
            // Desenhar pontos no canvas
            const drawPoints = () => {
                const canvas = dataCanvasRef.current;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Limpar canvas
                ctx.clearRect(0, 0, width, height);
                
                // Desenhar eixos
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(width/2, 0);
                ctx.lineTo(width/2, height);
                ctx.moveTo(0, height/2);
                ctx.lineTo(width, height/2);
                ctx.stroke();
                
                // Converter coordenadas
                const mapX = x => (x + 1) * width / 2;
                const mapY = y => height - ((y + 1) * height / 2);
                
                // Desenhar pontos
                points.forEach(point => {
                    ctx.fillStyle = point.class === 1 ? 'blue' : 'red';
                    ctx.beginPath();
                    ctx.arc(mapX(point.x), mapY(point.y), 5, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            };
            
            // Desenhar rede
            const drawNetwork = () => {
                const canvas = networkCanvasRef.current;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Limpar canvas
                ctx.clearRect(0, 0, width, height);
                
                // Arquitetura completa
                const architecture = [2, ...neurons, 1];
                const layers = architecture.length;
                
                // Dimensões
                const neuronRadius = 15;
                const horizontalSpacing = width / (layers + 1);
                
                // Desenhar camadas
                for (let l = 0; l < layers; l++) {
                    const numNeurons = architecture[l];
                    const layerX = horizontalSpacing * (l + 1);
                    const layerTop = height / 2 - (numNeurons * neuronRadius * 2.5) / 2;
                    
                    // Desenhar conexões
                    if (l < layers - 1) {
                        const nextLayerSize = architecture[l + 1];
                        const nextLayerX = horizontalSpacing * (l + 2);
                        const nextLayerTop = height / 2 - (nextLayerSize * neuronRadius * 2.5) / 2;
                        
                        for (let i = 0; i < numNeurons; i++) {
                            const startY = layerTop + i * neuronRadius * 2.5 + neuronRadius;
                            
                            for (let j = 0; j < nextLayerSize; j++) {
                                const endY = nextLayerTop + j * neuronRadius * 2.5 + neuronRadius;
                                
                                ctx.beginPath();
                                ctx.moveTo(layerX, startY);
                                ctx.lineTo(nextLayerX, endY);
                                ctx.strokeStyle = "#aaa";
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        }
                    }
                    
                    // Desenhar neurônios
                    for (let i = 0; i < numNeurons; i++) {
                        const y = layerTop + i * neuronRadius * 2.5 + neuronRadius;
                        
                        ctx.beginPath();
                        ctx.arc(layerX, y, neuronRadius, 0, Math.PI * 2);
                        
                        if (l === 0) {
                            ctx.fillStyle = "#e6f7ff"; // Entrada
                        } else if (l === layers - 1) {
                            ctx.fillStyle = "#e6fffa"; // Saída
                        } else {
                            ctx.fillStyle = "#f8f9fa"; // Oculta
                        }
                        
                        ctx.fill();
                        ctx.strokeStyle = "#aaa";
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Rótulo
                        ctx.fillStyle = "#333";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.font = "12px Arial";
                        
                        let label = "";
                        if (l === 0) {
                            label = i === 0 ? "x₁" : "x₂";
                        } else if (l === layers - 1) {
                            label = "y";
                        } else {
                            label = `h${i+1}`;
                        }
                        
                        ctx.fillText(label, layerX, y);
                    }
                    
                    // Rótulo da camada
                    ctx.fillStyle = "#555";
                    ctx.font = "12px Arial";
                    ctx.fillText(
                        l === 0 ? "Entrada" : l === layers - 1 ? "Saída" : `Oculta ${l}`,
                        layerX,
                        height - 10
                    );
                }
            };
            
            // Criar modelo
            const createModel = () => {
                if (model.current) {
                    model.current.dispose();
                }
                
                model.current = tf.sequential();
                
                // Camada de entrada
                model.current.add(tf.layers.dense({
                    units: neurons[0],
                    inputShape: [2],
                    activation: 'tanh'
                }));
                
                // Camadas ocultas adicionais
                for (let i = 1; i < neurons.length; i++) {
                    model.current.add(tf.layers.dense({
                        units: neurons[i],
                        activation: 'tanh'
                    }));
                }
                
                // Camada de saída
                model.current.add(tf.layers.dense({
                    units: 1,
                    activation: 'sigmoid'
                }));
                
                // Compilar
                model.current.compile({
                    optimizer: 'adam',
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });
            };
            
            // Treinar modelo
            const trainModel = async () => {
                if (points.length === 0) return;
                
                setTraining(true);
                setEpoch(0);
                
                createModel();
                
                // Preparar dados
                const inputs = points.map(p => [p.x, p.y]);
                const outputs = points.map(p => [p.class]);
                
                const xs = tf.tensor2d(inputs);
                const ys = tf.tensor2d(outputs);
                
                // Treinar época por época
                for (let e = 1; e <= maxEpochs; e++) {
                    await model.current.fit(xs, ys, {
                        epochs: 1,
                        batchSize: 32,
                        shuffle: true,
                        verbose: 0
                    });
                    
                    setEpoch(e);
                    
                    // Visualizar
                    if (e % 5 === 0 || e === maxEpochs) {
                        await visualizeModel();
                    }
                    
                    // Pausa para UI
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                // Limpar tensores
                xs.dispose();
                ys.dispose();
                
                setTraining(false);
            };
            
            // Visualizar modelo
            const visualizeModel = async () => {
                if (!model.current || !dataCanvasRef.current) return;
                
                const canvas = dataCanvasRef.current;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Desenhar fundo colorido
                const resolution = 50;
                const step = 2 / resolution;
                
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const x = -1 + (i * step);
                        const y = -1 + (j * step);
                        
                        // Prever classe
                        const prediction = await tf.tidy(() => {
                            const input = tf.tensor2d([[x, y]]);
                            const output = model.current.predict(input);
                            return output.dataSync()[0];
                        });
                        
                        // Mapear para canvas
                        const canvasX = (i / resolution) * width;
                        const canvasY = (j / resolution) * height;
                        const pixelSize = width / resolution;
                        
                        // Cor baseada na previsão
                        let color;
                        if (prediction > 0.5) {
                            // Azul para classe 1
                            const intensity = Math.min(1, (prediction - 0.5) * 2);
                            color = `rgba(0, 0, 255, ${0.3 + intensity * 0.4})`;
                        } else {
                            // Vermelho para classe 0
                            const intensity = Math.min(1, (0.5 - prediction) * 2);
                            color = `rgba(255, 0, 0, ${0.3 + intensity * 0.4})`;
                        }
                        
                        // Desenhar pixel
                        ctx.fillStyle = color;
                        ctx.fillRect(canvasX, canvasY, pixelSize, pixelSize);
                    }
                }
                
                // Redesenhar pontos
                drawPoints();
            };
            
            // Atualizar neurônios em uma camada
            const updateNeuron = (index, value) => {
                const newNeurons = [...neurons];
                newNeurons[index] = parseInt(value);
                setNeurons(newNeurons);
            };
            
            return (
                <div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '20px' }}>
                        {/* Painel de controle */}
                        <div style={{ padding: '16px', backgroundColor: '#f8f9fa', borderRadius: '8px' }}>
                            <h3 style={{ marginTop: 0, marginBottom: '16px' }}>Configuração da Rede</h3>
                            
                            <div style={{ marginBottom: '16px' }}>
                                <label style={{ display: 'block', marginBottom: '8px' }}>
                                    Camadas Ocultas: {numLayers}
                                </label>
                                <input
                                    type="range"
                                    min="1"
                                    max="3"
                                    value={numLayers}
                                    onChange={(e) => setNumLayers(parseInt(e.target.value))}
                                    style={{ width: '100%' }}
                                    disabled={training}
                                />
                            </div>
                            
                            {neurons.map((n, i) => (
                                <div key={i} style={{ marginBottom: '16px' }}>
                                    <label style={{ display: 'block', marginBottom: '8px' }}>
                                        Neurônios na Camada {i+1}: {n}
                                    </label>
                                    <input
                                        type="range"
                                        min="1"
                                        max="8"
                                        value={n}
                                        onChange={(e) => updateNeuron(i, e.target.value)}
                                        style={{ width: '100%' }}
                                        disabled={training}
                                    />
                                </div>
                            ))}
                            
                            <div style={{ marginBottom: '16px' }}>
                                <label style={{ display: 'block', marginBottom: '8px' }}>
                                    Épocas: {maxEpochs}
                                </label>
                                <input
                                    type="range"
                                    min="10"
                                    max="100"
                                    step="5"
                                    value={maxEpochs}
                                    onChange={(e) => setMaxEpochs(parseInt(e.target.value))}
                                    style={{ width: '100%' }}
                                    disabled={training}
                                />
                            </div>
                            
                            <div style={{ marginBottom: '16px' }}>
                                <button
                                    className="button"
                                    onClick={generateXORPoints}
                                    disabled={training}
                                >
                                    Gerar Pontos XOR
                                </button>
                                
                                <button
                                    className="button button-green"
                                    onClick={trainModel}
                                    disabled={training || points.length === 0}
                                    style={{ marginLeft: '8px' }}
                                >
                                    {training ? "Treinando..." : "Treinar Rede"}
                                </button>
                            </div>
                            
                            {training && (
                                <div style={{ marginBottom: '16px' }}>
                                    <div style={{ marginBottom: '8px' }}>
                                        Época: {epoch} / {maxEpochs}
                                    </div>
                                    <div className="progress-bar">
                                        <div 
                                            className="progress-bar-fill"
                                            style={{ width: `${(epoch / maxEpochs) * 100}%` }}
                                        ></div>
                                    </div>
                                </div>
                            )}
                            
                            <div style={{ marginTop: '16px', fontSize: '12px', color: '#6c757d' }}>
                                <p>Azul: Classe 1, Vermelho: Classe 0</p>
                                <p>Arquitetura: 2-{neurons.join('-')}-1</p>
                            </div>
                        </div>
                        
                        {/* Visualizações */}
                        <div>
                            <div style={{ marginBottom: '20px' }}>
                                <h3 style={{ marginTop: 0, marginBottom: '8px' }}>Visualização de Decisão</h3>
                                <canvas 
                                    ref={dataCanvasRef} 
                                    width={500} 
                                    height={400} 
                                    style={{ border: '1px solid #dee2e6', borderRadius: '4px', width: '100%', height: 'auto' }}
                                ></canvas>
                            </div>
                            
                            <div>
                                <h3 style={{ marginTop: 0, marginBottom: '8px' }}>Arquitetura da Rede</h3>
                                <canvas 
                                    ref={networkCanvasRef} 
                                    width={500} 
                                    height={200} 
                                    style={{ border: '1px solid #dee2e6', borderRadius: '4px', width: '100%', height: 'auto' }}
                                ></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Renderizar aplicação
        ReactDOM.render(<MLPDemo />, document.getElementById('app-container'));
    </script>
</body>
</html>
