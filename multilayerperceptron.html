<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multilayer Perceptron - IFSC IA</title>
    
    <!-- React e ReactDOM -->
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    
    <!-- Babel para JSX -->
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    
    <style>
        body {
            font-family: -apple-system, sans-serif;
            background-color: #f5f7fb;
            padding: 20px;
            margin: 0;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .back-button {
            display: inline-flex;
            align-items: center;
            color: blue;
            font-weight: bold;
            margin-bottom: 20px;
            text-decoration: none;
        }
        
        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .button {
            padding: 8px 16px;
            background: #4c6ef5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        
        .button:hover {
            background: #364fc7;
        }
        
        .button:disabled {
            background: #adb5bd;
            cursor: not-allowed;
        }
        
        .button-green {
            background: #40c057;
        }
        
        .button-green:hover {
            background: #2b9348;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .mb-4 {
            margin-bottom: 16px;
        }
        
        .progress-bar {
            width: 100%;
            background-color: #e9ecef;
            border-radius: 4px;
            height: 8px;
            overflow: hidden;
        }
        
        .progress-bar-fill {
            height: 100%;
            background-color: #4c6ef5;
            transition: width 0.2s;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-button">
            ← Voltar para Ferramentas
        </a>
        
        <h1>Multilayer Perceptron</h1>
        <p>Visualize como um perceptron multicamadas cria regiões de decisão complexas</p>
        
        <div id="app-container" class="card"></div>
        
        <div class="card">
            <h2>Teoria do Multilayer Perceptron (MLP)</h2>
            <p>O Multilayer Perceptron (MLP) é uma rede neural com múltiplas camadas que podem aprender padrões não-lineares complexos.</p>
            <p>Diferente de um único perceptron que só pode criar um hiperplano linear, um MLP combina vários hiperplanos para formar fronteiras de decisão complexas.</p>
            <p>Cada neurônio nas camadas ocultas contribui com seu próprio hiperplano, permitindo que a rede aprenda padrões que não são linearmente separáveis, como o problema XOR.</p>
            <p>Explore diferentes arquiteturas e observe como as fronteiras de decisão mudam com o número de camadas e neurônios. Use o slider de épocas para ver a evolução da aprendizagem!</p>
        </div>
        
        <footer style="text-align: center; margin-top: 40px; color: #6c757d;">
            <p>Desenvolvido por Ramon Mayor Martins - IFSC 2025</p>
            <p>Instituto Federal de Santa Catarina - Área de Telecomunicações</p>
        </footer>
    </div>
    
    <script type="text/babel">
        // Componente principal
        const MLPDemo = () => {
            // Estados
            const [numLayers, setNumLayers] = React.useState(1);
            const [neurons, setNeurons] = React.useState([4]);
            const [currentEpoch, setCurrentEpoch] = React.useState(0);
            const [maxEpochs, setMaxEpochs] = React.useState(50);
            const [points, setPoints] = React.useState([]);
            const [isInitialized, setIsInitialized] = React.useState(false);
            const [isTraining, setIsTraining] = React.useState(false);
            
            // Refs para canvas e modelo
            const dataCanvasRef = React.useRef(null);
            const networkCanvasRef = React.useRef(null);
            const modelRef = React.useRef(null);
            
            // Referência para armazenar modelos em diferentes épocas
            const modelsHistoryRef = React.useRef([]);
            
            // Gerar pontos XOR ao iniciar
            React.useEffect(() => {
                generateXORPoints();
            }, []);
            
            // Desenhar visualizações quando pontos mudam ou a configuração da rede muda
            React.useEffect(() => {
                if (dataCanvasRef.current) {
                    drawPoints();
                }
                if (networkCanvasRef.current) {
                    drawNetwork();
                }
            }, [points, neurons, numLayers]);
            
            // Atualizar neurônios quando o número de camadas muda
            React.useEffect(() => {
                const newNeurons = Array(numLayers).fill(4);
                setNeurons(newNeurons);
            }, [numLayers]);
            
            // Atualizar visualização quando a época muda
            React.useEffect(() => {
                if (isInitialized && currentEpoch >= 0 && currentEpoch < modelsHistoryRef.current.length) {
                    // Carregar modelo da época atual
                    visualizeEpoch(currentEpoch);
                }
            }, [currentEpoch, isInitialized]);
            
            // Gerar pontos XOR
            const generateXORPoints = () => {
                const newPoints = [];
                const count = 100;
                const jitter = 0.1;
                
                for (let i = 0; i < count / 4; i++) {
                    // Pontos no quadrante 1 (superior direito) - Classe 0
                    newPoints.push({ 
                        x: 0.5 + (Math.random() * jitter * 2 - jitter), 
                        y: 0.5 + (Math.random() * jitter * 2 - jitter), 
                        class: 0 
                    });
                    
                    // Pontos no quadrante 3 (inferior esquerdo) - Classe 0
                    newPoints.push({ 
                        x: -0.5 + (Math.random() * jitter * 2 - jitter), 
                        y: -0.5 + (Math.random() * jitter * 2 - jitter), 
                        class: 0 
                    });
                    
                    // Pontos no quadrante 2 (superior esquerdo) - Classe 1
                    newPoints.push({ 
                        x: -0.5 + (Math.random() * jitter * 2 - jitter), 
                        y: 0.5 + (Math.random() * jitter * 2 - jitter), 
                        class: 1 
                    });
                    
                    // Pontos no quadrante 4 (inferior direito) - Classe 1
                    newPoints.push({ 
                        x: 0.5 + (Math.random() * jitter * 2 - jitter), 
                        y: -0.5 + (Math.random() * jitter * 2 - jitter), 
                        class: 1 
                    });
                }
                
                setPoints(newPoints);
                setCurrentEpoch(0);
                setIsInitialized(false);
                modelsHistoryRef.current = [];
            };
            
            // Gerar pontos círculos
            const generateCirclePoints = () => {
                const newPoints = [];
                const count = 200;
                
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = Math.random();
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    // Classe 1 para pontos dentro do círculo interno, Classe 0 para fora
                    const pointClass = radius < 0.5 ? 1 : 0;
                    newPoints.push({ x, y, class: pointClass });
                }
                
                setPoints(newPoints);
                setCurrentEpoch(0);
                setIsInitialized(false);
                modelsHistoryRef.current = [];
            };
            
            // Desenhar pontos no canvas
            const drawPoints = () => {
                const canvas = dataCanvasRef.current;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Limpar canvas
                ctx.clearRect(0, 0, width, height);
                
                // Desenhar eixos
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(width/2, 0);
                ctx.lineTo(width/2, height);
                ctx.moveTo(0, height/2);
                ctx.lineTo(width, height/2);
                ctx.stroke();
                
                // Converter coordenadas
                const mapX = x => (x + 1) * width / 2;
                const mapY = y => height - ((y + 1) * height / 2);
                
                // Desenhar pontos
                points.forEach(point => {
                    ctx.fillStyle = point.class === 1 ? 'blue' : 'red';
                    ctx.beginPath();
                    ctx.arc(mapX(point.x), mapY(point.y), 5, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            };
            
            // Desenhar rede
            const drawNetwork = () => {
                const canvas = networkCanvasRef.current;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Limpar canvas
                ctx.clearRect(0, 0, width, height);
                
                // Arquitetura completa
                const architecture = [2, ...neurons, 1];
                const layers = architecture.length;
                
                // Dimensões
                const neuronRadius = 15;
                const horizontalSpacing = width / (layers + 1);
                
                // Desenhar camadas
                for (let l = 0; l < layers; l++) {
                    const numNeurons = architecture[l];
                    const layerX = horizontalSpacing * (l + 1);
                    const layerTop = height / 2 - (numNeurons * neuronRadius * 2.5) / 2;
                    
                    // Desenhar conexões
                    if (l < layers - 1) {
                        const nextLayerSize = architecture[l + 1];
                        const nextLayerX = horizontalSpacing * (l + 2);
                        const nextLayerTop = height / 2 - (nextLayerSize * neuronRadius * 2.5) / 2;
                        
                        for (let i = 0; i < numNeurons; i++) {
                            const startY = layerTop + i * neuronRadius * 2.5 + neuronRadius;
                            
                            for (let j = 0; j < nextLayerSize; j++) {
                                const endY = nextLayerTop + j * neuronRadius * 2.5 + neuronRadius;
                                
                                ctx.beginPath();
                                ctx.moveTo(layerX, startY);
                                ctx.lineTo(nextLayerX, endY);
                                ctx.strokeStyle = "#aaa";
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        }
                    }
                    
                    // Desenhar neurônios
                    for (let i = 0; i < numNeurons; i++) {
                        const y = layerTop + i * neuronRadius * 2.5 + neuronRadius;
                        
                        ctx.beginPath();
                        ctx.arc(layerX, y, neuronRadius, 0, Math.PI * 2);
                        
                        if (l === 0) {
                            ctx.fillStyle = "#e6f7ff"; // Entrada
                        } else if (l === layers - 1) {
                            ctx.fillStyle = "#e6fffa"; // Saída
                        } else {
                            ctx.fillStyle = "#f8f9fa"; // Oculta
                        }
                        
                        ctx.fill();
                        ctx.strokeStyle = "#aaa";
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Rótulo
                        ctx.fillStyle = "#333";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.font = "12px Arial";
                        
                        let label = "";
                        if (l === 0) {
                            label = i === 0 ? "x₁" : "x₂";
                        } else if (l === layers - 1) {
                            label = "y";
                        } else {
                            label = `h${i+1}`;
                        }
                        
                        ctx.fillText(label, layerX, y);
                    }
                    
                    // Rótulo da camada
                    ctx.fillStyle = "#555";
                    ctx.font = "12px Arial";
                    ctx.fillText(
                        l === 0 ? "Entrada" : l === layers - 1 ? "Saída" : `Oculta ${l}`,
                        layerX,
                        height - 10
                    );
                }
            };
            
            // Criar modelo
            const createModel = () => {
                if (modelRef.current) {
                    modelRef.current.dispose();
                }
                
                modelRef.current = tf.sequential();
                
                // Camada de entrada
                modelRef.current.add(tf.layers.dense({
                    units: neurons[0],
                    inputShape: [2],
                    activation: 'tanh'
                }));
                
                // Camadas ocultas adicionais
                for (let i = 1; i < neurons.length; i++) {
                    modelRef.current.add(tf.layers.dense({
                        units: neurons[i],
                        activation: 'tanh'
                    }));
                }
                
                // Camada de saída
                modelRef.current.add(tf.layers.dense({
                    units: 1,
                    activation: 'sigmoid'
                }));
                
                // Compilar
                modelRef.current.compile({
                    optimizer: 'adam',
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });
            };
            
            // Salvar modelo atual
            const saveCurrentModel = (epoch) => {
                // Extrair e salvar pesos do modelo
                const layerWeights = [];
                for (let i = 0; i < modelRef.current.layers.length; i++) {
                    const weights = modelRef.current.layers[i].getWeights();
                    layerWeights.push({
                        kernelWeights: weights[0] ? weights[0].arraySync() : null,
                        biasWeights: weights[1] ? weights[1].arraySync() : null
                    });
                }
                
                // Salvar pesos do modelo para esta época
                modelsHistoryRef.current[epoch] = layerWeights;
            };
            
            // Carregar modelo salvo
            const loadModelFromSaved = (epoch) => {
                if (!modelsHistoryRef.current[epoch]) return;
                
                // Recriar modelo com a arquitetura atual
                createModel();
                
                // Carregar pesos salvos
                const savedWeights = modelsHistoryRef.current[epoch];
                for (let i = 0; i < modelRef.current.layers.length; i++) {
                    if (i < savedWeights.length && savedWeights[i].kernelWeights && savedWeights[i].biasWeights) {
                        const kernelWeights = tf.tensor(savedWeights[i].kernelWeights);
                        const biasWeights = tf.tensor(savedWeights[i].biasWeights);
                        modelRef.current.layers[i].setWeights([kernelWeights, biasWeights]);
                    }
                }
            };
            
            // Visualizar modelo para uma época específica
            const visualizeEpoch = (epoch) => {
                if (epoch < 0 || epoch >= modelsHistoryRef.current.length) return;
                
                // Carregar modelo da época selecionada
                loadModelFromSaved(epoch);
                
                // Visualizar este modelo
                visualizePredictions();
            };
            
            // Visualizar predições do modelo atual
            const visualizePredictions = async () => {
                if (!modelRef.current || !dataCanvasRef.current) return;
                
                const canvas = dataCanvasRef.current;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Limpar canvas
                ctx.clearRect(0, 0, width, height);
                
                // Desenhar regiões de decisão
                const resolution = 50;
                const step = 2 / resolution;
                
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const x = -1 + (i * step);
                        const y = -1 + (j * step);
                        
                        // Prever classe
                        const prediction = await tf.tidy(() => {
                            const input = tf.tensor2d([[x, y]]);
                            const output = modelRef.current.predict(input);
                            return output.dataSync()[0];
                        });
                        
                        // Mapear para canvas
                        const canvasX = (i / resolution) * width;
                        const canvasY = (j / resolution) * height;
                        const pixelSize = width / resolution;
                        
                        // Cor baseada na previsão
                        let color;
                        if (prediction > 0.5) {
                            // Azul para classe 1
                            const intensity = Math.min(1, (prediction - 0.5) * 2);
                            color = `rgba(0, 0, 255, ${0.3 + intensity * 0.4})`;
                        } else {
                            // Vermelho para classe 0
                            const intensity = Math.min(1, (0.5 - prediction) * 2);
                            color = `rgba(255, 0, 0, ${0.3 + intensity * 0.4})`;
                        }
                        
                        // Desenhar pixel
                        ctx.fillStyle = color;
                        ctx.fillRect(canvasX, canvasY, pixelSize, pixelSize);
                    }
                }
                
                // Redesenhar pontos
                drawPoints();
            };
            
            // Treinar modelo
            const trainModel = async () => {
                if (points.length === 0) return;
                
                setIsTraining(true);
                setCurrentEpoch(0);
                
                // Criar e inicializar modelo
                createModel();
                
                // Preparar dados
                const inputs = points.map(p => [p.x, p.y]);
                const outputs = points.map(p => [p.class]);
                
                const xs = tf.tensor2d(inputs);
                const ys = tf.tensor2d(outputs);
                
                // Reset histórico de modelos
                modelsHistoryRef.current = [];
                
                // Salvar modelo inicial (época 0)
                saveCurrentModel(0);
                
                // Treinar e salvar modelo a cada época
                for (let e = 1; e <= maxEpochs; e++) {
                    await modelRef.current.fit(xs, ys, {
                        epochs: 1,
                        batchSize: 32,
                        shuffle: true,
                        verbose: 0
                    });
                    
                    // Salvar modelo desta época
                    saveCurrentModel(e);
                }
                
                // Limpar tensores
                xs.dispose();
                ys.dispose();
                
                setIsInitialized(true);
                setIsTraining(false);
                
                // Visualizar modelo final
                setCurrentEpoch(maxEpochs);
            };
            
            // Atualizar neurônios em uma camada
            const updateNeuron = (index, value) => {
                const newNeurons = [...neurons];
                newNeurons[index] = parseInt(value);
                setNeurons(newNeurons);
                setIsInitialized(false);
            };
            
            return (
                <div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '20px' }}>
                        {/* Painel de controle */}
                        <div style={{ padding: '16px', backgroundColor: '#f8f9fa', borderRadius: '8px' }}>
                            <h3 style={{ marginTop: 0, marginBottom: '16px' }}>Configuração da Rede</h3>
                            
                            <div style={{ marginBottom: '16px' }}>
                                <label style={{ display: 'block', marginBottom: '8px' }}>
                                    Camadas Ocultas: {numLayers}
                                </label>
                                <input
                                    type="range"
                                    min="1"
                                    max="3"
                                    value={numLayers}
                                    onChange={(e) => setNumLayers(parseInt(e.target.value))}
                                    style={{ width: '100%' }}
                                    disabled={isTraining}
                                />
                            </div>
                            
                            {neurons.map((n, i) => (
                                <div key={i} style={{ marginBottom: '16px' }}>
                                    <label style={{ display: 'block', marginBottom: '8px' }}>
                                        Neurônios na Camada {i+1}: {n}
                                    </label>
                                    <input
                                        type="range"
                                        min="1"
                                        max="8"
                                        value={n}
                                        onChange={(e) => updateNeuron(i, e.target.value)}
                                        style={{ width: '100%' }}
                                        disabled={isTraining}
                                    />
                                </div>
                            ))}
                            
                            <div style={{ marginBottom: '16px' }}>
                                <label style={{ display: 'block', marginBottom: '8px' }}>
                                    Máximo de Épocas: {maxEpochs}
                                </label>
                                <input
                                    type="range"
                                    min="10"
                                    max="100"
                                    step="5"
                                    value={maxEpochs}
                                    onChange={(e) => setMaxEpochs(parseInt(e.target.value))}
                                    style={{ width: '100%' }}
                                    disabled={isTraining}
                                />
                            </div>
                            
                            <div style={{ marginBottom: '16px' }}>
                                <button
                                    className="button"
                                    onClick={generateXORPoints}
                                    disabled={isTraining}
                                >
                                    Gerar XOR
                                </button>
                                
                                <button
                                    className="button"
                                    onClick={generateCirclePoints}
                                    disabled={isTraining}
                                    style={{ marginLeft: '8px' }}
                                >
                                    Gerar Círculos
                                </button>
                                
                                <button
                                    className="button button-green"
                                    onClick={trainModel}
                                    disabled={isTraining || points.length === 0}
                                    style={{ marginTop: '8px', width: '100%' }}
                                >
                                    {isTraining ? "Treinando..." : "Treinar Rede"}
                                </button>
                            </div>
                            
                            {isInitialized && (
                                <div style={{ marginBottom: '16px' }}>
                                    <label style={{ display: 'block', marginBottom: '8px' }}>
                                        Época: {currentEpoch} / {maxEpochs}
                                    </label>
                                    <input
                                        type="range"
                                        min="0"
                                        max={maxEpochs}
                                        value={currentEpoch}
                                        onChange={(e) => setCurrentEpoch(parseInt(e.target.value))}
                                        style={{ width: '100%' }}
                                    />
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: '4px' }}>
                                        <small>Inicial</small>
                                        <small>Final</small>
                                    </div>
                                </div>
                            )}
                            
                            {isTraining && (
                                <div style={{ marginBottom: '16px' }}>
                                    <div style={{ marginBottom: '8px' }}>
                                        Treinando... Por favor aguarde.
                                    </div>
                                    <div className="progress-bar">
                                        <div 
                                            className="progress-bar-fill"
                                            style={{ width: `${(currentEpoch / maxEpochs) * 100}%` }}
                                        ></div>
                                    </div>
                                </div>
                            )}
                            
                            <div style={{ marginTop: '16px', fontSize: '12px', color: '#6c757d' }}>
                                <p>Azul: Classe 1, Vermelho: Classe 0</p>
                                <p>Arquitetura: 2-{neurons.join('-')}-1</p>
                                <p>Use o slider de época para ver a evolução da aprendizagem!</p>
                            </div>
                        </div>
                        
                        {/* Visualizações */}
                        <div>
                            <div style={{ marginBottom: '20px' }}>
                                <h3 style={{ marginTop: 0, marginBottom: '8px' }}>Visualização de Decisão</h3>
                                <canvas 
                                    ref={dataCanvasRef} 
                                    width={500} 
                                    height={400} 
                                    style={{ border: '1px solid #dee2e6', borderRadius: '4px', width: '100%', height: 'auto' }}
                                ></canvas>
                            </div>
                            
                            <div>
                                <h3 style={{ marginTop: 0, marginBottom: '8px' }}>Arquitetura da Rede</h3>
                                <canvas 
                                    ref={networkCanvasRef} 
                                    width={500} 
                                    height={200} 
                                    style={{ border: '1px solid #dee2e6', borderRadius: '4px', width: '100%', height: 'auto' }}
                                ></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Renderizar aplicação
        ReactDOM.render(<MLPDemo />, document.getElementById('app-container'));
    </script>
</body>
</html>
