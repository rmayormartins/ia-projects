<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multilayer Perceptron - IFSC IA</title>
    
    <!-- React e ReactDOM -->
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    
    <!-- Babel para JSX -->
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- TensorFlow.js para cálculos de redes neurais -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #f5f7fb;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .back-button {
            display: inline-flex;
            align-items: center;
            color: #4e54c8;
            font-weight: 600;
            margin-bottom: 20px;
            transition: transform 0.2s ease;
        }
        
        .back-button:hover {
            transform: translateX(-5px);
        }

        #root {
            min-height: 650px;
            margin-bottom: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            Voltar para Ferramentas
        </a>
        
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-gray-800">Multilayer Perceptron</h1>
            <p class="text-gray-600 mt-2">Visualize como um perceptron multicamadas cria regiões de decisão complexas</p>
        </header>
        
        <div id="root" class="p-4 rounded-lg"></div>
        
        <div class="mt-8 bg-white p-6 rounded-lg shadow-sm">
            <h2 class="text-xl font-bold mb-4">Teoria do Multilayer Perceptron (MLP)</h2>
            <p class="mb-3">O Multilayer Perceptron (MLP) é uma rede neural com múltiplas camadas de neurônios interconectados, capaz de aprender relações não-lineares complexas nos dados.</p>
            <p class="mb-3">Enquanto um único perceptron só pode criar um hiperplano linear (uma linha reta em 2D), um MLP pode criar fronteiras de decisão complexas e não-lineares, permitindo classificar dados que não são linearmente separáveis.</p>
            <p class="mb-3">Ao adicionar mais camadas e neurônios, a rede pode formar regiões de decisão mais complexas. Cada neurônio na camada oculta cria seu próprio hiperplano, e a combinação deles resulta em fronteiras de decisão não-lineares.</p>
            <p class="mb-3">Use o controle de épocas para visualizar como a rede aprende progressivamente a separar os dados. Observe como os pesos da rede se ajustam durante o treinamento, destacados no diagrama da arquitetura abaixo.</p>
        </div>
        
        <footer class="mt-12 text-center text-gray-600 text-sm">
            <p>Desenvolvido por Ramon Mayor Martins - IFSC 2025</p>
            <p class="mt-1">Instituto Federal de Santa Catarina - Área de Telecomunicações</p>
        </footer>
    </div>
    
    <script type="text/babel">
        const MultilayerPerceptron = () => {
          // Estado para configurações básicas
          const [numLayers, setNumLayers] = React.useState(1);
          const [neuronsPerLayer, setNeuronsPerLayer] = React.useState([4]);
          const [currentEpoch, setCurrentEpoch] = React.useState(0);
          const [maxEpochs, setMaxEpochs] = React.useState(50);
          const [points, setPoints] = React.useState([]);
          const [colors, setColors] = React.useState([]);
          const [modelTrained, setModelTrained] = React.useState(false);
          const [training, setTraining] = React.useState(false);
          const [weights, setWeights] = React.useState([]);
          
          // Referências para canvas
          const canvasRef = React.useRef(null);
          const networkCanvasRef = React.useRef(null);
          const model = React.useRef(null);
          
          // Gerar dados iniciais
          React.useEffect(() => {
            generatePoints('xor');
          }, []);
          
          // Renderizar visualizações quando necessário
          React.useEffect(() => {
            drawPoints();
            drawNetworkArchitecture();
            if (modelTrained && currentEpoch > 0) {
              visualizeDecision();
            }
          }, [points, numLayers, neuronsPerLayer, currentEpoch, modelTrained]);
          
          // Atualizar número de neurônios quando o número de camadas muda
          React.useEffect(() => {
            const newNeurons = Array(numLayers).fill(4);
            setNeuronsPerLayer(newNeurons);
            setModelTrained(false);
          }, [numLayers]);
          
          // Gerar pontos de treinamento
          const generatePoints = (type = 'xor') => {
            const newPoints = [];
            const count = 200;
            
            if (type === 'xor') {
              // Problema XOR (não linearmente separável)
              const jitter = 0.1;
              for (let i = 0; i < count / 4; i++) {
                // Pontos no quadrante 1 (superior direito) - Classe 0
                newPoints.push({ 
                  x: 0.5 + (Math.random() * jitter * 2 - jitter), 
                  y: 0.5 + (Math.random() * jitter * 2 - jitter), 
                  class: 0 
                });
                
                // Pontos no quadrante 3 (inferior esquerdo) - Classe 0
                newPoints.push({ 
                  x: -0.5 + (Math.random() * jitter * 2 - jitter), 
                  y: -0.5 + (Math.random() * jitter * 2 - jitter), 
                  class: 0 
                });
                
                // Pontos no quadrante 2 (superior esquerdo) - Classe 1
                newPoints.push({ 
                  x: -0.5 + (Math.random() * jitter * 2 - jitter), 
                  y: 0.5 + (Math.random() * jitter * 2 - jitter), 
                  class: 1 
                });
                
                // Pontos no quadrante 4 (inferior direito) - Classe 1
                newPoints.push({ 
                  x: 0.5 + (Math.random() * jitter * 2 - jitter), 
                  y: -0.5 + (Math.random() * jitter * 2 - jitter), 
                  class: 1 
                });
              }
            } else if (type === 'circles') {
              // Círculos concêntricos
              for (let i = 0; i < count; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random();
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                // Classe 1 para pontos dentro do círculo interno, Classe 0 para fora
                const pointClass = radius < 0.5 ? 1 : 0;
                newPoints.push({ x, y, class: pointClass });
              }
            } else {
              // Padrão de clusters
              for (let i = 0; i < count / 4; i++) {
                // Cluster superior esquerdo - Classe 1
                newPoints.push({ 
                  x: -0.5 + Math.random() * 0.4, 
                  y: 0.5 + Math.random() * 0.4, 
                  class: 1 
                });
                
                // Cluster inferior direito - Classe 1
                newPoints.push({ 
                  x: 0.5 + Math.random() * 0.4, 
                  y: -0.5 + Math.random() * 0.4, 
                  class: 1 
                });
                
                // Cluster superior direito - Classe 0
                newPoints.push({ 
                  x: 0.5 + Math.random() * 0.4, 
                  y: 0.5 + Math.random() * 0.4, 
                  class: 0 
                });
                
                // Cluster inferior esquerdo - Classe 0
                newPoints.push({ 
                  x: -0.5 + Math.random() * 0.4, 
                  y: -0.5 + Math.random() * 0.4, 
                  class: 0 
                });
              }
            }
            
            setPoints(newPoints);
            setModelTrained(false);
            setCurrentEpoch(0);
            setColors([]);
          };
          
          // Desenhar pontos no canvas
          const drawPoints = () => {
            if (!canvasRef.current) return;
            
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Limpar canvas se não tiver mapa de cores
            if (!colors.length) {
              ctx.clearRect(0, 0, width, height);
            }
            
            // Desenhar eixos
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height/2);
            ctx.lineTo(width, height/2);
            ctx.moveTo(width/2, 0);
            ctx.lineTo(width/2, height);
            ctx.stroke();
            
            // Função para converter coordenadas
            const mapX = x => (x + 1) * width / 2;
            const mapY = y => height - ((y + 1) * height / 2);
            
            // Desenhar pontos
            points.forEach(point => {
              ctx.fillStyle = point.class === 1 ? 'blue' : 'red';
              ctx.beginPath();
              ctx.arc(mapX(point.x), mapY(point.y), 5, 0, 2 * Math.PI);
              ctx.fill();
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 1;
              ctx.stroke();
            });
          };
          
          // Criar modelo de rede neural
          const createModel = () => {
            if (model.current) {
              model.current.dispose();
            }
            
            model.current = tf.sequential();
            
            // Criar camadas da rede
            model.current.add(tf.layers.dense({
              units: neuronsPerLayer[0],
              inputShape: [2],
              activation: 'tanh',
              kernelInitializer: 'heNormal'
            }));
            
            // Adicionar camadas ocultas adicionais
            for (let i = 1; i < neuronsPerLayer.length; i++) {
              model.current.add(tf.layers.dense({
                units: neuronsPerLayer[i],
                activation: 'tanh',
                kernelInitializer: 'heNormal'
              }));
            }
            
            // Camada de saída
            model.current.add(tf.layers.dense({
              units: 1,
              activation: 'sigmoid',
              kernelInitializer: 'heNormal'
            }));
            
            // Compilar o modelo
            model.current.compile({
              optimizer: 'adam',
              loss: 'binaryCrossentropy',
              metrics: ['accuracy']
            });
          };
          
          // Treinar o modelo por épocas
          const trainModel = async () => {
            if (points.length === 0) return;
            
            setTraining(true);
            setCurrentEpoch(0);
            setModelTrained(false);
            
            createModel();
            
            // Preparar dados
            const inputs = points.map(p => [p.x, p.y]);
            const outputs = points.map(p => [p.class]);
            
            const xs = tf.tensor2d(inputs);
            const ys = tf.tensor2d(outputs);
            
            // Histórico de pesos para visualização por época
            const weightHistory = [];
            
            // Treinar uma época de cada vez
            for (let epoch = 1; epoch <= maxEpochs; epoch++) {
              await model.current.fit(xs, ys, {
                epochs: 1,
                batchSize: 32,
                shuffle: true
              });
              
              // Extrair pesos para visualização
              const extractedWeights = [];
              for (let i = 0; i < model.current.layers.length; i++) {
                const layerWeights = model.current.layers[i].getWeights();
                if (layerWeights.length > 0) {
                  extractedWeights.push({
                    weights: layerWeights[0].arraySync(), // Pesos
                    biases: layerWeights[1].arraySync()   // Biases
                  });
                }
              }
              
              weightHistory.push(extractedWeights);
              
              // Atualizar estado após cada época
              setCurrentEpoch(epoch);
              setWeights(extractedWeights);
              
              // Visualizar decisão no final de cada época
              await visualizeDecision();
              
              // Pausa para permitir atualização da UI
              await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // Limpar tensores
            xs.dispose();
            ys.dispose();
            
            setModelTrained(true);
            setTraining(false);
          };
          
          // Visualizar regiões de decisão
          const visualizeDecision = async () => {
            if (!model.current || !canvasRef.current) return;
            
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Criar grade de pontos para visualização
            const resolution = 50;
            const gridSize = resolution;
            const grid = [];
            
            for (let i = 0; i < gridSize; i++) {
              for (let j = 0; j < gridSize; j++) {
                const x = (i / (gridSize - 1)) * 2 - 1;
                const y = (j / (gridSize - 1)) * 2 - 1;
                grid.push([x, y]);
              }
            }
            
            // Fazer previsões para cada ponto da grade
            const predictions = await tf.tidy(() => {
              const gridTensor = tf.tensor2d(grid);
              const preds = model.current.predict(gridTensor);
              return preds.dataSync();
            });
            
            // Limpar canvas e desenhar mapa de cores
            ctx.clearRect(0, 0, width, height);
            
            const newColors = [];
            for (let i = 0; i < grid.length; i++) {
              const x = grid[i][0];
              const y = grid[i][1];
              const pred = predictions[i];
              
              // Mapear para coordenadas do canvas
              const canvasX = ((x + 1) / 2) * width;
              const canvasY = height - ((y + 1) / 2) * height;
              
              // Tamanho do ponto baseado na resolução
              const pixelSize = width / gridSize + 1;
              
              // Cor baseada na previsão
              const strength = Math.abs(pred - 0.5) * 2;
              let r, g, b, a;
              
              if (pred >= 0.5) { // Classe 1 (azul)
                r = Math.floor(100 * (1 - strength));
                g = Math.floor(100 * (1 - strength));
                b = 255;
              } else { // Classe 0 (vermelho)
                r = 255;
                g = Math.floor(100 * (1 - strength));
                b = Math.floor(100 * (1 - strength));
              }
              
              a = 0.5 + (strength * 0.5);
              
              // Desenhar retângulo colorido
              ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
              ctx.fillRect(canvasX, canvasY, pixelSize, pixelSize);
              
              newColors.push({ x: canvasX, y: canvasY, color: `rgba(${r},${g},${b},${a})` });
            }
            
            setColors(newColors);
            
            // Desenhar fronteira de decisão (onde a previsão é 0.5)
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.lineWidth = 2;
            
            // Encontrar pontos próximos da fronteira
            const boundaryPoints = [];
            for (let i = 0; i < grid.length; i++) {
              if (Math.abs(predictions[i] - 0.5) < 0.1) {
                const x = ((grid[i][0] + 1) / 2) * width;
                const y = height - ((grid[i][1] + 1) / 2) * height;
                boundaryPoints.push({ x, y });
              }
            }
            
            // Desenhar fronteira de decisão
            if (boundaryPoints.length > 0) {
              ctx.beginPath();
              for (let i = 0; i < boundaryPoints.length; i++) {
                if (i === 0) {
                  ctx.moveTo(boundaryPoints[i].x, boundaryPoints[i].y);
                } else {
                  ctx.lineTo(boundaryPoints[i].x, boundaryPoints[i].y);
                }
              }
              ctx.stroke();
            }
            
            // Redesenhar pontos por cima
            drawPoints();
          };
          
          // Desenhar arquitetura da rede
          const drawNetworkArchitecture = () => {
            if (!networkCanvasRef.current) return;
            
            const canvas = networkCanvasRef.current;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Definir arquitetura completa (entrada, ocultas, saída)
            const architecture = [2, ...neuronsPerLayer, 1];
            const layers = architecture.length;
            
            // Dimensões
            const neuronRadius = 15;
            const horizontalSpacing = width / (layers + 1);
            
            // Desenhar conexões primeiro
            if (weights.length > 0) {
              for (let l = 0; l < layers - 1; l++) {
                const leftLayer = architecture[l];
                const rightLayer = architecture[l + 1];
                
                const leftX = horizontalSpacing * (l + 1);
                const rightX = horizontalSpacing * (l + 2);
                
                const leftLayerTop = height / 2 - (leftLayer * neuronRadius * 2.5) / 2;
                const rightLayerTop = height / 2 - (rightLayer * neuronRadius * 2.5) / 2;
                
                // Se temos pesos para esta camada
                if (l < weights.length) {
                  for (let i = 0; i < leftLayer; i++) {
                    const startY = leftLayerTop + i * neuronRadius * 2.5 + neuronRadius;
                    
                    for (let j = 0; j < rightLayer; j++) {
                      const endY = rightLayerTop + j * neuronRadius * 2.5 + neuronRadius;
                      
                      // Desenhar conexão com base no peso
                      const weight = weights[l].weights[i][j] || 0;
                      const absWeight = Math.abs(weight);
                      
                      // Largura e cor baseadas no peso
                      ctx.lineWidth = Math.max(0.5, Math.min(5, absWeight * 3));
                      
                      if (weight > 0) {
                        ctx.strokeStyle = `rgba(0, 128, 0, ${Math.min(1, absWeight)})`;
                      } else {
                        ctx.strokeStyle = `rgba(255, 0, 0, ${Math.min(1, absWeight)})`;
                      }
                      
                      ctx.beginPath();
                      ctx.moveTo(leftX, startY);
                      ctx.lineTo(rightX, endY);
                      ctx.stroke();
                    }
                  }
                } else {
                  // Se não temos pesos, desenhar linhas cinzas
                  for (let i = 0; i < leftLayer; i++) {
                    const startY = leftLayerTop + i * neuronRadius * 2.5 + neuronRadius;
                    
                    for (let j = 0; j < rightLayer; j++) {
                      const endY = rightLayerTop + j * neuronRadius * 2.5 + neuronRadius;
                      
                      ctx.lineWidth = 0.5;
                      ctx.strokeStyle = "#ccc";
                      ctx.beginPath();
                      ctx.moveTo(leftX, startY);
                      ctx.lineTo(rightX, endY);
                      ctx.stroke();
                    }
                  }
                }
              }
            }
            
            // Desenhar neurônios por cima das conexões
            for (let l = 0; l < layers; l++) {
              const numNeurons = architecture[l];
              const layerX = horizontalSpacing * (l + 1);
              const layerTop = height / 2 - (numNeurons * neuronRadius * 2.5) / 2;
              
              ctx.fillStyle = l === 0 ? "#f0f0f0" : l === layers - 1 ? "#e6f7ff" : "#f5f5f5";
              ctx.strokeStyle = "#aaa";
              ctx.lineWidth = 1;
              
              for (let i = 0; i < numNeurons; i++) {
                const y = layerTop + i * neuronRadius * 2.5 + neuronRadius;
                
                // Desenhar círculo
                ctx.beginPath();
                ctx.arc(layerX, y, neuronRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Adicionar rótulo
                ctx.fillStyle = "#333";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = "10px Arial";
                
                let label = "";
                if (l === 0) {
                  label = i === 0 ? "x₁" : "x₂";
                } else if (l === layers - 1) {
                  label = "y";
                } else {
                  label = `h${l}_${i+1}`;
                }
                
                ctx.fillText(label, layerX, y);
                
                // Mostrar bias se disponível
                if (l > 0 && weights.length >= l) {
                  const bias = weights[l-1].biases[i] || 0;
                  const biasText = bias.toFixed(1);
                  
                  ctx.font = "8px Arial";
                  ctx.fillStyle = bias > 0 ? "green" : "red";
                  ctx.fillText(biasText, layerX, y + neuronRadius + 8);
                }
              }
              
              // Adicionar rótulo da camada
              ctx.fillStyle = "#555";
              ctx.font = "12px Arial";
              ctx.fillText(
                l === 0 ? "Entrada" : l === layers - 1 ? "Saída" : `Oculta ${l}`,
                layerX,
                height - 10
              );
            }
          };
          
          // Alterar número de neurônios em uma camada
          const updateNeurons = (index, value) => {
            const newNeurons = [...neuronsPerLayer];
            newNeurons[index] = parseInt(value);
            setNeuronsPerLayer(newNeurons);
            setModelTrained(false);
          };
          
          return (
            <div className="flex flex-col md:flex-row gap-6">
              {/* Controles */}
              <div className="w-full md:w-1/3 bg-gray-50 p-4 rounded-lg">
                <h3 className="text-lg font-bold mb-4">Configuração</h3>
                
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Número de Camadas Ocultas: {numLayers}
                  </label>
                  <input
                    type="range"
                    min="1"
                    max="3"
                    value={numLayers}
                    onChange={(e) => setNumLayers(parseInt(e.target.value))}
                    className="w-full"
                    disabled={training}
                  />
                </div>
                
                {neuronsPerLayer.map((neurons, i) => (
                  <div key={i} className="mb-4">
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Neurônios na Camada {i+1}: {neurons}
                    </label>
                    <input
                      type="range"
                      min="1"
                      max="8"
                      value={neurons}
                      onChange={(e) => updateNeurons(i, e.target.value)}
                      className="w-full"
                      disabled={training}
                    />
                  </div>
                ))}
                
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Épocas: {maxEpochs}
                  </label>
                  <input
                    type="range"
                    min="10"
                    max="100"
                    step="5"
                    value={maxEpochs}
                    onChange={(e) => setMaxEpochs(parseInt(e.target.value))}
                    className="w-full"
                    disabled={training}
                  />
                </div>
                
                <div className="grid grid-cols-2 gap-2 mb-4">
                  <button
                    className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                    onClick={() => generatePoints('clusters')}
                    disabled={training}
                  >
                    Gerar Clusters
                  </button>
                  <button
                    className="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600"
                    onClick={() => generatePoints('circles')}
                    disabled={training}
                  >
                    Gerar Círculos
                  </button>
                  <button
                    className="px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600"
                    onClick={() => generatePoints('xor')}
                    disabled={training}
                  >
                    Gerar XOR
                  </button>
                  <button
                    className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
                    onClick={trainModel}
                    disabled={training || points.length === 0}
                  >
                    {training ? "Treinando..." : modelTrained ? "Treinar Novamente" : "Treinar Rede"}
                  </button>
                </div>
                
                {training && (
                  <div className="mb-4">
                    <div className="text-sm font-medium text-gray-700 mb-1">
                      Época: {currentEpoch} / {maxEpochs}
                    </div>
                    <div className="w-full bg-gray-200 rounded-full h-2.5">
                      <div 
                        className="bg-blue-600 h-2.5 rounded-full"
                        style={{ width: `${(currentEpoch / maxEpochs) * 100}%` }}
                      ></div>
                    </div>
                  </div>
                )}
                
                <div className="mt-4 bg-white p-3 rounded-lg border border-gray-200">
                  <h4 className="font-medium text-gray-800 mb-2">Informações:</h4>
                  <ul className="text-sm space-y-1">
                    <li><span className="font-medium">Arquitetura:</span> 2-{neuronsPerLayer.join('-')}-1</li>
                    <li><span className="font-medium">Total de neurônios:</span> {2 + neuronsPerLayer.reduce((a, b) => a + b, 0) + 1}</li>
                    <li><span className="font-medium">Ativação:</span> tanh (camadas ocultas), sigmoid (saída)
                        <li><span className="font-medium">Época atual:</span> {currentEpoch} de {maxEpochs}</li>
                  </ul>
                </div>
                
                <div className="mt-4 text-xs text-gray-500">
                  <p>Azul: Classe 1, Vermelho: Classe 0</p>
                  <p>Conexões verdes: pesos positivos, Vermelhas: pesos negativos</p>
                  <p>Linhas pretas: fronteiras de decisão</p>
                </div>
              </div>
              
              {/* Visualizações */}
              <div className="w-full md:w-2/3 flex flex-col">
                <div className="bg-white p-4 rounded-lg shadow-sm mb-4">
                  <h3 className="text-lg font-bold mb-2">Regiões de Decisão</h3>
                  <p className="text-sm text-gray-600 mb-2">
                    Hiperplanos gerados pela rede para classificar os dados. As áreas coloridas mostram as regiões de decisão.
                  </p>
                  <div className="border border-gray-200 rounded overflow-hidden">
                    <canvas 
                      ref={canvasRef} 
                      width={500} 
                      height={400} 
                      className="w-full bg-white"
                    />
                  </div>
                </div>
                
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h3 className="text-lg font-bold mb-2">Arquitetura da Rede</h3>
                  <p className="text-sm text-gray-600 mb-2">
                    Estrutura do MLP com {neuronsPerLayer.join(',')} neurônios nas camadas ocultas.
                  </p>
                  <div className="border border-gray-200 rounded overflow-hidden">
                    <canvas 
                      ref={networkCanvasRef} 
                      width={600} 
                      height={280} 
                      className="w-full bg-white"
                    />
                  </div>
                </div>
              </div>
            </div>
          );
        };

        // Renderizar o componente
        try {
          ReactDOM.render(
            <MultilayerPerceptron />,
            document.getElementById('root')
          );
          console.log("Componente MLP renderizado com sucesso!");
        } catch (e) {
          console.error("Erro ao renderizar o componente:", e);
          
          // Tentar novamente após um pequeno atraso
          setTimeout(() => {
            try {
              ReactDOM.render(
                <MultilayerPerceptron />,
                document.getElementById('root')
              );
              console.log("Componente MLP renderizado com sucesso após atraso!");
            } catch (e) {
              console.error("Erro ao renderizar o componente após atraso:", e);
            }
          }, 1000);
        }
    </script>
</body>
</html>
